import { Telegraf } from 'telegraf';
import axios from 'axios';
import cron from 'node-cron';

// ==================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ====================
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const CHAT_ID = process.env.TELEGRAM_CHAT_ID;

if (!BOT_TOKEN) {
  console.error('‚ùå TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!');
  process.exit(1);
}

console.log('‚úÖ Bot token –Ω–∞–π–¥–µ–Ω');
console.log('üì± Chat ID:', CHAT_ID || '–ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù (–ø–æ–ª—É—á–∏—Ç–µ —á–µ—Ä–µ–∑ /chatid)');

// ==================== –ù–ê–°–¢–†–û–ô–ö–ò –¢–û–†–ì–û–í–õ–ò ====================
const CONFIG = {
  // CoinGecko API
  apiUrl: 'https://api.coingecko.com/api/v3',
  topCoins: 50,
  
  // –§–∏–ª—å—Ç—Ä—ã
  minVolume: 30000000,        // $30M –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–±—ä–µ–º
  minMarketCap: 300000000,    // $300M –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è
  minConfidence: 60,          // 60% –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
  minQualityScore: 4,         // 4/10 –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
  minRRRatio: 2.0,            // 1:2 –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–ø—Ä–∏–±—ã–ª—å
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–∏ —É—Ä–æ–≤–Ω–µ–π
  godTier: {
    qualityScore: 6,
    confidence: 75,
    rrRatio: 3.0
  },
  premium: {
    qualityScore: 4,
    confidence: 60,
    rrRatio: 2.0
  }
};

// ==================== TELEGRAM BOT ====================
const bot = new Telegraf(BOT_TOKEN);

// –ö–æ–º–∞–Ω–¥–∞ /start
bot.start((ctx) => {
  const chatId = ctx.chat.id;
  const username = ctx.chat.username ? `@${ctx.chat.username}` : '–ù–µ—Ç username';
  const firstName = ctx.chat.first_name || '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å';
  
  console.log(`üí¨ /start –æ—Ç chat ID: ${chatId}, User: ${firstName} ${username}`);
  
  ctx.reply(
    `ü§ñ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Crypto Signals Bot!\n\n` +
    `üìä –í–∞—à Chat ID: <code>${chatId}</code>\n` +
    `üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${firstName} ${username}\n\n` +
    `üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç–æ—Ç Chat ID –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è:\n` +
    `<code>TELEGRAM_CHAT_ID=${chatId}</code>\n\n` +
    `üìà –°–∏–≥–Ω–∞–ª—ã –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å —Å—é–¥–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç.`,
    { parse_mode: 'HTML' }
  );
});

// –ö–æ–º–∞–Ω–¥–∞ /chatid
bot.command('chatid', (ctx) => {
  const chatId = ctx.chat.id;
  console.log(`üí¨ /chatid –æ—Ç chat ID: ${chatId}`);
  ctx.reply(
    `üí¨ –í–∞—à Chat ID: <code>${chatId}</code>\n\n` +
    `–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ–≥–æ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–∞ Render:\n` +
    `<code>TELEGRAM_CHAT_ID=${chatId}</code>`,
    { parse_mode: 'HTML' }
  );
});

// –ö–æ–º–∞–Ω–¥–∞ /test - —Ç–µ—Å—Ç–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
bot.command('test', async (ctx) => {
  console.log('üß™ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞...');
  
  const testSignal = {
    pair: 'BTC/USDT',
    signal: 'LONG',
    entry: 45000,
    tp: 48000,
    sl: 43500,
    confidence: 85,
    qualityScore: 8,
    rrRatio: 3.5,
    tier: 'GOD TIER',
    exchange: 'BINANCE',
    indicators: {
      rsi: 28,
      volatility: 5.2
    },
    confirmations: ['RSI_OVERSOLD', 'MACD_BULLISH', 'BB_OVERSOLD']
  };
  
  await sendSignalToTelegram(testSignal);
  ctx.reply('‚úÖ –¢–µ—Å—Ç–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!');
});

// ==================== –ò–ù–î–ò–ö–ê–¢–û–†–´ ====================
function calculateSMA(prices, period) {
  if (prices.length < period) return null;
  const sum = prices.slice(-period).reduce((a, b) => a + b, 0);
  return sum / period;
}

function calculateEMA(prices, period) {
  if (prices.length < period) return null;
  const multiplier = 2 / (period + 1);
  let ema = calculateSMA(prices.slice(0, period), period);
  
  for (let i = period; i < prices.length; i++) {
    ema = (prices[i] - ema) * multiplier + ema;
  }
  return ema;
}

function calculateRSI(prices, period = 14) {
  if (prices.length < period + 1) return 50;
  
  let gains = 0;
  let losses = 0;
  
  for (let i = 1; i <= period; i++) {
    const change = prices[prices.length - i] - prices[prices.length - i - 1];
    if (change > 0) gains += change;
    else losses -= change;
  }
  
  const avgGain = gains / period;
  const avgLoss = losses / period;
  
  if (avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - 100 / (1 + rs);
}

function calculateMACD(prices) {
  const ema12 = calculateEMA(prices, 12);
  const ema26 = calculateEMA(prices, 26);
  if (!ema12 || !ema26) return { macd: 0, signal: 0, histogram: 0 };
  
  const macd = ema12 - ema26;
  const signal = calculateEMA(prices.slice(-9), 9) || macd;
  const histogram = macd - signal;
  
  return { macd, signal, histogram };
}

function calculateBollingerBands(prices, period = 20) {
  if (prices.length < period) return { upper: null, middle: null, lower: null };
  
  const sma = calculateSMA(prices, period);
  const variance = prices.slice(-period)
    .reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
  const stdDev = Math.sqrt(variance);
  
  return {
    upper: sma + stdDev * 2,
    middle: sma,
    lower: sma - stdDev * 2
  };
}

function calculateVolatility(prices, period = 20) {
  if (prices.length < period) return 0;
  
  const recentPrices = prices.slice(-period);
  const mean = recentPrices.reduce((a, b) => a + b, 0) / period;
  const variance = recentPrices.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / period;
  return (Math.sqrt(variance) / mean) * 100;
}

// ==================== –ê–ù–ê–õ–ò–ó –°–ò–ì–ù–ê–õ–ê ====================
function analyzeSignal(coin, priceHistory) {
  const price = coin.current_price;
  const volume = coin.total_volume;
  const marketCap = coin.market_cap;
  
  // –§–∏–ª—å—Ç—Ä—ã
  if (volume < CONFIG.minVolume) return null;
  if (marketCap < CONFIG.minMarketCap) return null;
  if (priceHistory.length < 100) return null;
  
  // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
  const rsi = calculateRSI(priceHistory);
  const macd = calculateMACD(priceHistory);
  const bb = calculateBollingerBands(priceHistory);
  const volatility = calculateVolatility(priceHistory);
  const sma20 = calculateSMA(priceHistory, 20);
  const sma50 = calculateSMA(priceHistory, 50);
  
  // –ü–æ–¥—Å—á–µ—Ç –∫–∞—á–µ—Å—Ç–≤–∞ –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π
  let qualityScore = 0;
  const confirmations = [];
  
  // RSI
  if (rsi < 30) {
    qualityScore += 2;
    confirmations.push('RSI_OVERSOLD');
  } else if (rsi > 70) {
    qualityScore += 2;
    confirmations.push('RSI_OVERBOUGHT');
  }
  
  // MACD
  if (macd.histogram > 0 && macd.macd > macd.signal) {
    qualityScore += 1;
    confirmations.push('MACD_BULLISH');
  } else if (macd.histogram < 0 && macd.macd < macd.signal) {
    qualityScore += 1;
    confirmations.push('MACD_BEARISH');
  }
  
  // Bollinger Bands
  if (price < bb.lower) {
    qualityScore += 2;
    confirmations.push('BB_OVERSOLD');
  } else if (price > bb.upper) {
    qualityScore += 2;
    confirmations.push('BB_OVERBOUGHT');
  }
  
  // –¢—Ä–µ–Ω–¥
  if (sma20 > sma50) {
    qualityScore += 1;
    confirmations.push('TREND_BULLISH');
  } else if (sma20 < sma50) {
    qualityScore += 1;
    confirmations.push('TREND_BEARISH');
  }
  
  // –û–±—ä–µ–º
  if (volume > CONFIG.minVolume * 2) {
    qualityScore += 1;
    confirmations.push('HIGH_VOLUME');
  }
  
  // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
  if (qualityScore < CONFIG.minQualityScore) return null;
  if (confirmations.length < 2) return null;
  
  // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞
  let signal = null;
  let confidence = 0;
  
  // LONG —Å–∏–≥–Ω–∞–ª
  if (
    (rsi < 35 && macd.histogram > 0) ||
    (price < bb.lower && rsi < 40) ||
    (rsi < 30 && sma20 > sma50)
  ) {
    signal = 'LONG';
    const trendBonus = sma20 > sma50 ? 1.15 : 1.0;
    confidence = Math.min(
      (55 + (35 - rsi) * 1.2 + confirmations.length * 4) * trendBonus,
      95
    );
  }
  // SHORT —Å–∏–≥–Ω–∞–ª
  else if (
    (rsi > 65 && macd.histogram < 0) ||
    (price > bb.upper && rsi > 60) ||
    (rsi > 70 && sma20 < sma50)
  ) {
    signal = 'SHORT';
    const trendBonus = sma20 < sma50 ? 1.15 : 1.0;
    confidence = Math.min(
      (55 + (rsi - 65) * 1.2 + confirmations.length * 4) * trendBonus,
      95
    );
  }
  
  if (!signal || confidence < CONFIG.minConfidence) return null;
  
  // –†–∞—Å—á–µ—Ç —Ü–µ–Ω
  const entry = price;
  let sl, tp, rrRatio;
  
  if (signal === 'LONG') {
    sl = entry * 0.96;  // -4% —Å—Ç–æ–ø-–ª–æ—Å—Å
    tp = entry + (entry - sl) * CONFIG.minRRRatio;
    rrRatio = (tp - entry) / (entry - sl);
  } else {
    sl = entry * 1.04;  // +4% —Å—Ç–æ–ø-–ª–æ—Å—Å
    tp = entry - (sl - entry) * CONFIG.minRRRatio;
    rrRatio = (entry - tp) / (sl - entry);
  }
  
  if (rrRatio < CONFIG.minRRRatio) return null;
  
  // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
  const isGodTier = 
    qualityScore >= CONFIG.godTier.qualityScore &&
    confidence >= CONFIG.godTier.confidence &&
    rrRatio >= CONFIG.godTier.rrRatio;
  
  const isPremium = !isGodTier &&
    qualityScore >= CONFIG.premium.qualityScore &&
    confidence >= CONFIG.premium.confidence &&
    rrRatio >= CONFIG.premium.rrRatio;
  
  if (!isGodTier && !isPremium) return null;
  
  return {
    pair: `${coin.symbol.toUpperCase()}/USDT`,
    signal,
    entry: parseFloat(entry.toFixed(6)),
    tp: parseFloat(tp.toFixed(6)),
    sl: parseFloat(sl.toFixed(6)),
    confidence: Math.round(confidence),
    qualityScore,
    rrRatio: parseFloat(rrRatio.toFixed(2)),
    tier: isGodTier ? 'GOD TIER' : 'PREMIUM',
    exchange: ['BINANCE', 'BYBIT', 'OKX', 'KUCOIN'][Math.floor(Math.random() * 4)],
    indicators: {
      rsi: Math.round(rsi),
      volatility: parseFloat(volatility.toFixed(2))
    },
    confirmations,
    timestamp: new Date()
  };
}

// ==================== –ü–û–õ–£–ß–ï–ù–ò–ï –î–ê–ù–ù–´–• ====================
async function fetchMarketData() {
  try {
    const url = `${CONFIG.apiUrl}/coins/markets?vs_currency=usd&order=volume_desc&per_page=${CONFIG.topCoins}&page=1&sparkline=true`;
    const response = await axios.get(url);
    return response.data;
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö:', error.message);
    return [];
  }
}

// ==================== –ì–ï–ù–ï–†–ê–¶–ò–Ø –°–ò–ì–ù–ê–õ–û–í ====================
async function generateSignals() {
  console.log('üîç –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤...');
  
  const marketData = await fetchMarketData();
  if (marketData.length === 0) {
    console.log('‚ö†Ô∏è  –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö —Å —Ä—ã–Ω–∫–∞');
    return [];
  }
  
  const signals = [];
  
  for (const coin of marketData) {
    const priceHistory = coin.sparkline_in_7d?.price;
    if (!priceHistory || priceHistory.length < 100) continue;
    
    const signal = analyzeSignal(coin, priceHistory);
    if (signal) {
      signals.push(signal);
    }
  }
  
  // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: —Å–Ω–∞—á–∞–ª–∞ GOD TIER, –ø–æ—Ç–æ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É
  signals.sort((a, b) => {
    if (a.tier === 'GOD TIER' && b.tier !== 'GOD TIER') return -1;
    if (a.tier !== 'GOD TIER' && b.tier === 'GOD TIER') return 1;
    return b.qualityScore - a.qualityScore;
  });
  
  console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ ${signals.length} —Å–∏–≥–Ω–∞–ª–æ–≤`);
  
  // –î–µ—Ç–∞–ª—å–Ω—ã–π –≤—ã–≤–æ–¥
  if (signals.length > 0) {
    signals.forEach((s, i) => {
      console.log(`  ${i+1}. ${s.pair} ${s.signal} | ${s.tier} | Q=${s.qualityScore} C=${s.confidence}% RR=1:${s.rrRatio}`);
    });
  }
  
  return signals;
}

// ==================== –û–¢–ü–†–ê–í–ö–ê –í TELEGRAM ====================
async function sendSignalToTelegram(signal) {
  if (!CHAT_ID) {
    console.log('‚ö†Ô∏è  CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, —Å–∏–≥–Ω–∞–ª –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω');
    return false;
  }
  
  try {
    const direction = signal.signal === 'LONG' ? 'üü¢ LONG' : 'üî¥ SHORT';
    const tierEmoji = signal.tier === 'GOD TIER' ? 'üî•' : '‚≠ê';
    
    const message = `
${tierEmoji} <b>${signal.tier} SIGNAL</b>
${direction} <b>${signal.pair}</b>

üíµ Entry: $${signal.entry}
üéØ Take Profit: $${signal.tp}
üõë Stop Loss: $${signal.sl}

üìä R:R Ratio: 1:${signal.rrRatio}
üé≤ Confidence: ${signal.confidence}%
üèÜ Quality: ${signal.qualityScore}/10

üìà RSI: ${signal.indicators.rsi}
üìä Volatility: ${signal.indicators.volatility}%

üîç Confirmations:
${signal.confirmations.map(c => `  ‚Ä¢ ${c}`).join('\n')}

üè¶ Exchange: ${signal.exchange}
‚è∞ ${signal.timestamp.toLocaleString('ru-RU')}
    `.trim();
    
    await bot.telegram.sendMessage(CHAT_ID, message, { parse_mode: 'HTML' });
    console.log(`‚úÖ –°–∏–≥–Ω–∞–ª ${signal.pair} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Telegram`);
    return true;
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram:', error.message);
    return false;
  }
}

// ==================== CRON –ó–ê–î–ê–ß–ê ====================
async function runSignalsTask() {
  console.log('\nüîÑ === –ó–ê–ü–£–°–ö –ó–ê–î–ê–ß–ò ===');
  console.log(`‚è∞ –í—Ä–µ–º—è: ${new Date().toLocaleString('ru-RU')}`);
  
  try {
    const signals = await generateSignals();
    
    if (signals.length === 0) {
      console.log('‚ÑπÔ∏è  –°–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
      return;
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º 5 –ª—É—á—à–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
    const signalsToSend = signals.slice(0, 5);
    console.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ ${signalsToSend.length} —Å–∏–≥–Ω–∞–ª–æ–≤...`);
    
    for (const signal of signalsToSend) {
      await sendSignalToTelegram(signal);
      // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
    
    console.log('‚úÖ –ó–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞\n');
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –≤ –∑–∞–¥–∞—á–µ:', error.message);
  }
}

// ==================== –ó–ê–ü–£–°–ö ====================
async function start() {
  try {
    // –£–¥–∞–ª—è–µ–º webhook –∏ –∑–∞–ø—É—Å–∫–∞–µ–º long polling
    await bot.telegram.deleteWebhook();
    console.log('‚úÖ Webhook —É–¥–∞–ª–µ–Ω');
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ
    const botInfo = await bot.telegram.getMe();
    console.log(`‚úÖ –ë–æ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω: @${botInfo.username}`);
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    bot.launch();
    console.log('‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω (long polling)');
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º CRON –∑–∞–¥–∞—á—É –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
    cron.schedule('*/5 * * * *', runSignalsTask);
    console.log('‚úÖ CRON –∑–∞–¥–∞—á–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ (–∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç)');
    
    // –ü–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
    console.log('‚è≥ –ü–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥...\n');
    setTimeout(runSignalsTask, 10000);
    
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞:', error.message);
    process.exit(1);
  }
}

// Graceful shutdown
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));

// –ó–∞–ø—É—Å–∫
start();
